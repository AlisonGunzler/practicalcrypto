"""Solution to Assignment 3.

Python version 3.9 or later.

Your final submission must contain the following functions:
    - brute_force_dl(mod, gen, order, target)
    - baby_step_giant_step_dl(mod, gen, order, target):
    - crt(vals, mods)
    - pohlig_hellman(mod, gen, factors, target)
    - elgamal_attack(params, pk)
"""


import math

# import numpy as np


def brute_force_dl(mod, gen, order, target):
    """Uses brute force to compute discrete log of target with respect to gen.

    Parameters:
        mod (int): The prime modulus over which computation is carried out.
        gen (int): An element of Z*_mod.
        order (int): The order of the subgroup generated by gen.
        target (int): The element whose discrete log is to be computed.

    Returns:
        int: The discrete log of target with respect to gen.
    """

    for i in range(order) :
        if(pow(gen,i,mod) == target) :
            return i

    return 0

def find_inverse (g, n):
    return pow(g,-1,n) #TODO fix

def baby_step_giant_step_dl(mod, gen, order, target):
    """Uses the baby step giant step algorithm to compute discrete log of
    target with respect to gen.

    Parameters:
        mod (int): The prime modulus over which computation is carried out.
        gen (int): An element of Z*_mod.
        order (int): The order of the subgroup generated by gen.
        target (int): The element whose discrete log is to be computed.

    Returns:
        int: The discrete log of target with respect to gen.
    """

    m = math.isqrt(order) + 1  

    table0 = {} #TODO hash???
    ct = 1
    for j in range(m):
        table0[ct] = j
        ct = (ct * gen) % mod 

    # am = find_inverse(pow(gen, m, mod), mod)
    am = pow(pow(gen, m, mod), -1, mod)

    y = target

    for i in range(m) :
        if y in table0:
            index = table0[y]
            return i*m + index
        y = (y * am) % mod


    return 0


def crt(vals, mods):
    """Solves a system of congruences.

    Parameters:
        vals (list(int)): A list of values.
        mods (list(int)): A list of moduli which are pairwise coprime i.e., mod[i] and mod[j] are
            coprime for any i ≠ j. The length of this list is equal to that of vals.

    Returns:
        int: An integer z such that for every i in {0, .., len(vals) - 1}, z ≡ vals[i] mod mods[i].
    """

    M = math.prod(mods)
    n = len(mods)
    

    m_sum = 0
    for i in range(n) :
        mi = mods[i]
        bi = (M // mi)
        bi_inv = find_inverse(bi, mi)
        ai = vals[i]

        m_sum += (ai*bi*bi_inv) 


    return m_sum % M

# helper function for pohlig_hellman
def gppo(mod, gen, p,e, pei, target) :
    #n=pei
    #n=pei

    x = 0
    y = pow(gen, pei//p, mod)

    for k in range(e) :

        gk = pow(pow(gen, x, mod), -1, mod)
        gkh = (gk * target) % mod
        exp = pow(p, e-1-k)
        hk = pow(gkh, exp, mod)
        dk = baby_step_giant_step_dl(mod, y, p-1, hk)
        x = x + pow(p,k) * dk

    return x



def pohlig_hellman(mod, gen, factors, target):
    """Uses the Pohlig-Hellman algorithm to compute discrete log of target with
    respect to gen, given the factorization of the order of the subgroup
    generated by gen.

    Parameters:
        mod (int): The prime modulus over which computation is carried out.
        gen (int): An element of Z*_mod.
        factors (list(int, int)): A list of values [(p_1, e_1), ..., (p_n, e_n)] such that the order
            of the subgroup generated by gen is p_1^{e_1} * ... * p_n^{e_n}.
        target (int): The element whose discrete log is to be computed.

    Returns:
        int: The discrete log of target with respect to gen.
    """

    #finding order

    r = len(factors)
    n = 1
    pei_list = list()

    for i in range(r) :
        pei = pow(factors[i][0], factors[i][1])
        n = n*pei
        pei_list.append(pei)

    vals = list()
    mods = list()

    for j in range(r) :
        pei = pei_list[j]
        p = factors[j][0]
        e = factors[j][1]

        gi = pow(gen, n//pei, mod)
        hi = pow(target, n//pei, mod)
        xi = gppo(mod, gi, p, e, pei, hi)

        vals.append(xi)
        mods.append(pei)

    x = crt(vals, mods)

    return x


def elgamal_attack(params, pk):
    """
    Given an ElGamal public key in Z*_mod, where mod is prime, recovers the corresponding secret
    key when mod - 1 has sufficiently many 'small' prime factors.

    Parameters:
        params (Params): ElGamal parameters. It is an instance of the Params class defined in
            problem.py.
        pk (int): The ElGamal public key. It is guaranteed that the corresponding secret key is
            less than params.exp_bound.

    Returns:
        int: The discrete log of pk with respect to gen.
    """

    mod = params.mod
    factors = params.factors
    gen = params.gen
    exp_bound = params.exp_bound

    r = len(factors)
    n = 1

    for i in range(r) :
        pei = pow(factors[i][0], factors[i][1])
        n = n*pei

    
    smalls = list()
    sum_under_100 = 1
    factors.sort()

    for f in factors:

        base, exp = f
        factor_value = pow(base, exp)
        sum_under_100 *= factor_value
        smalls.append(f) 

        if  (sum_under_100 >= exp_bound):
            break  
        

    cofac = n // sum_under_100
    new_gen = pow(gen, cofac, mod)
    new_target = pow(pk, cofac, mod)

    
    return pohlig_hellman(mod, new_gen, smalls, new_target)

    



    




    #pk=B, sk=a, A=gen, A^a = B, find A
    # return pohlig_hellman(mod, gen, factors, pk)












    # return 0
